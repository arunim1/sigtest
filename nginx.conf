events {
    worker_connections 1024;
}

# test with curl -X POST "http://httpbin.org/anything" 

http {
    log_format debug_log '[$time_local] $remote_addr - $remote_user - $server_name '
                        'to: $upstream_addr: $request upstream_response_time $upstream_response_time '
                        'request_time $request_time '
                        'status: $status request_body: $request_body '
                        'custom_header: $http_custom_header '
                        'host: $http_host '
                        'uri: $request_uri';

    access_log /dev/stdout debug_log;
    error_log /dev/stdout debug;

    # Resolve DNS using Docker's DNS server
    resolver 127.0.0.11 valid=30s ipv6=off;

    server {
        listen 80;
        # Remove SSL configuration for now since we don't have certificates
        # listen 443 ssl;
        server_name _;

        set $logging_backend "logging-server:8000";

        set $id 12093;

        # Define the signer service
        set $signer_backend "signer:8001";

        # Define a mirror location
        location = /_mirror {
            internal;
            proxy_set_header Host $http_host; 
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            # proxy_set_header custom-header "intercepted";
            proxy_set_header test-id $id;
            
            # Get signature before proxying
            auth_request /_sign;
            auth_request_set $request_timestamp $upstream_http_x_timestamp;
            auth_request_set $request_signature $upstream_http_x_signature;

            # Add headers
            proxy_set_header Test-Request-Timestamp $request_timestamp;
            proxy_set_header Test-Request-ID $id;
            proxy_set_header Test-Request-Signature $request_signature;

            proxy_pass http://$logging_backend$request_uri;
            
            # Don't wait for logging server response
            proxy_ignore_client_abort on;
            proxy_read_timeout 1s;
            proxy_connect_timeout 1s;
        }

        location / {
            # Mirror the request to the logging location
            mirror /_mirror;
            mirror_request_body on;

            # Get signature before proxying
            auth_request /_sign;
            auth_request_set $request_timestamp $upstream_http_x_timestamp;
            auth_request_set $request_signature $upstream_http_x_signature;

            # Add headers
            proxy_set_header Test-Request-Timestamp $request_timestamp;
            proxy_set_header Test-Request-ID $id;
            proxy_set_header Test-Request-Signature $request_signature;

            # Remove HTTPS handling since we're only doing HTTP for now
            # proxy_set_header custom-header "intercepted";
            proxy_set_header test-id $id;
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            proxy_pass http://$http_host$request_uri;
            # proxy_pass http://logging-server:8000;
        }

        # Internal signing endpoint
        location = /_sign {
            internal;
            proxy_pass http://$signer_backend/sign?id=$id;
            proxy_pass_request_body off;
            proxy_set_header Content-Length "";
            proxy_set_header X-Original-URI $request_uri;
        }
    }
}